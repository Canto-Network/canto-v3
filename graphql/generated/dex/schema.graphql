"""
creates a virtual field on the entity that may be queried but cannot be set manually through the mappings API.
"""
directive @derivedFrom(field: String!) on FIELD_DEFINITION

"""
Marks the GraphQL type as indexable entity.  Each type that should be an entity is required to be annotated with this directive.
"""
directive @entity on OBJECT

"""Defined a Subgraph ID for an object type"""
directive @subgraphId(id: String!) on OBJECT

scalar BigDecimal

scalar BigInt

input BlockChangedFilter {
  number_gte: Int!
}

input Block_height {
  hash: Bytes
  number: Int
  number_gte: Int
}

type Bundle {
  ethPrice: BigDecimal!
  id: ID!
}

input Bundle_filter {
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [Bundle_filter]
  ethPrice: BigDecimal
  ethPrice_gt: BigDecimal
  ethPrice_gte: BigDecimal
  ethPrice_in: [BigDecimal!]
  ethPrice_lt: BigDecimal
  ethPrice_lte: BigDecimal
  ethPrice_not: BigDecimal
  ethPrice_not_in: [BigDecimal!]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  or: [Bundle_filter]
}

enum Bundle_orderBy {
  ethPrice
  id
}

type Burn {
  amount0: BigDecimal
  amount1: BigDecimal
  amountUSD: BigDecimal
  feeLiquidity: BigDecimal
  feeTo: Bytes
  id: ID!
  liquidity: BigDecimal!
  logIndex: BigInt
  needsComplete: Boolean!
  pair: Pair!
  sender: Bytes
  timestamp: BigInt!
  to: Bytes
  transaction: Transaction!
}

input Burn_filter {
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  amount0: BigDecimal
  amount0_gt: BigDecimal
  amount0_gte: BigDecimal
  amount0_in: [BigDecimal!]
  amount0_lt: BigDecimal
  amount0_lte: BigDecimal
  amount0_not: BigDecimal
  amount0_not_in: [BigDecimal!]
  amount1: BigDecimal
  amount1_gt: BigDecimal
  amount1_gte: BigDecimal
  amount1_in: [BigDecimal!]
  amount1_lt: BigDecimal
  amount1_lte: BigDecimal
  amount1_not: BigDecimal
  amount1_not_in: [BigDecimal!]
  amountUSD: BigDecimal
  amountUSD_gt: BigDecimal
  amountUSD_gte: BigDecimal
  amountUSD_in: [BigDecimal!]
  amountUSD_lt: BigDecimal
  amountUSD_lte: BigDecimal
  amountUSD_not: BigDecimal
  amountUSD_not_in: [BigDecimal!]
  and: [Burn_filter]
  feeLiquidity: BigDecimal
  feeLiquidity_gt: BigDecimal
  feeLiquidity_gte: BigDecimal
  feeLiquidity_in: [BigDecimal!]
  feeLiquidity_lt: BigDecimal
  feeLiquidity_lte: BigDecimal
  feeLiquidity_not: BigDecimal
  feeLiquidity_not_in: [BigDecimal!]
  feeTo: Bytes
  feeTo_contains: Bytes
  feeTo_gt: Bytes
  feeTo_gte: Bytes
  feeTo_in: [Bytes!]
  feeTo_lt: Bytes
  feeTo_lte: Bytes
  feeTo_not: Bytes
  feeTo_not_contains: Bytes
  feeTo_not_in: [Bytes!]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  liquidity: BigDecimal
  liquidity_gt: BigDecimal
  liquidity_gte: BigDecimal
  liquidity_in: [BigDecimal!]
  liquidity_lt: BigDecimal
  liquidity_lte: BigDecimal
  liquidity_not: BigDecimal
  liquidity_not_in: [BigDecimal!]
  logIndex: BigInt
  logIndex_gt: BigInt
  logIndex_gte: BigInt
  logIndex_in: [BigInt!]
  logIndex_lt: BigInt
  logIndex_lte: BigInt
  logIndex_not: BigInt
  logIndex_not_in: [BigInt!]
  needsComplete: Boolean
  needsComplete_in: [Boolean!]
  needsComplete_not: Boolean
  needsComplete_not_in: [Boolean!]
  or: [Burn_filter]
  pair: String
  pair_: Pair_filter
  pair_contains: String
  pair_contains_nocase: String
  pair_ends_with: String
  pair_ends_with_nocase: String
  pair_gt: String
  pair_gte: String
  pair_in: [String!]
  pair_lt: String
  pair_lte: String
  pair_not: String
  pair_not_contains: String
  pair_not_contains_nocase: String
  pair_not_ends_with: String
  pair_not_ends_with_nocase: String
  pair_not_in: [String!]
  pair_not_starts_with: String
  pair_not_starts_with_nocase: String
  pair_starts_with: String
  pair_starts_with_nocase: String
  sender: Bytes
  sender_contains: Bytes
  sender_gt: Bytes
  sender_gte: Bytes
  sender_in: [Bytes!]
  sender_lt: Bytes
  sender_lte: Bytes
  sender_not: Bytes
  sender_not_contains: Bytes
  sender_not_in: [Bytes!]
  timestamp: BigInt
  timestamp_gt: BigInt
  timestamp_gte: BigInt
  timestamp_in: [BigInt!]
  timestamp_lt: BigInt
  timestamp_lte: BigInt
  timestamp_not: BigInt
  timestamp_not_in: [BigInt!]
  to: Bytes
  to_contains: Bytes
  to_gt: Bytes
  to_gte: Bytes
  to_in: [Bytes!]
  to_lt: Bytes
  to_lte: Bytes
  to_not: Bytes
  to_not_contains: Bytes
  to_not_in: [Bytes!]
  transaction: String
  transaction_: Transaction_filter
  transaction_contains: String
  transaction_contains_nocase: String
  transaction_ends_with: String
  transaction_ends_with_nocase: String
  transaction_gt: String
  transaction_gte: String
  transaction_in: [String!]
  transaction_lt: String
  transaction_lte: String
  transaction_not: String
  transaction_not_contains: String
  transaction_not_contains_nocase: String
  transaction_not_ends_with: String
  transaction_not_ends_with_nocase: String
  transaction_not_in: [String!]
  transaction_not_starts_with: String
  transaction_not_starts_with_nocase: String
  transaction_starts_with: String
  transaction_starts_with_nocase: String
}

enum Burn_orderBy {
  amount0
  amount1
  amountUSD
  feeLiquidity
  feeTo
  id
  liquidity
  logIndex
  needsComplete
  pair
  pair__createdAtBlockNumber
  pair__createdAtTimestamp
  pair__id
  pair__liquidityProviderCount
  pair__reserve0
  pair__reserve1
  pair__reserveETH
  pair__reserveUSD
  pair__stable
  pair__token0Price
  pair__token1Price
  pair__totalSupply
  pair__trackedReserveETH
  pair__txCount
  pair__untrackedVolumeUSD
  pair__volumeToken0
  pair__volumeToken1
  pair__volumeUSD
  sender
  timestamp
  to
  transaction
  transaction__blockNumber
  transaction__id
  transaction__timestamp
}

scalar Bytes

"8 bytes signed integer\n"
scalar Int8

type LiquidityPosition {
  id: ID!
  liquidityTokenBalance: BigDecimal!
  pair: Pair!
  user: User!
}

type LiquidityPositionSnapshot {
  block: Int!
  id: ID!
  liquidityPosition: LiquidityPosition!
  liquidityTokenBalance: BigDecimal!
  liquidityTokenTotalSupply: BigDecimal!
  pair: Pair!
  reserve0: BigDecimal!
  reserve1: BigDecimal!
  reserveUSD: BigDecimal!
  timestamp: Int!
  token0PriceUSD: BigDecimal!
  token1PriceUSD: BigDecimal!
  user: User!
}

input LiquidityPositionSnapshot_filter {
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [LiquidityPositionSnapshot_filter]
  block: Int
  block_gt: Int
  block_gte: Int
  block_in: [Int!]
  block_lt: Int
  block_lte: Int
  block_not: Int
  block_not_in: [Int!]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  liquidityPosition: String
  liquidityPosition_: LiquidityPosition_filter
  liquidityPosition_contains: String
  liquidityPosition_contains_nocase: String
  liquidityPosition_ends_with: String
  liquidityPosition_ends_with_nocase: String
  liquidityPosition_gt: String
  liquidityPosition_gte: String
  liquidityPosition_in: [String!]
  liquidityPosition_lt: String
  liquidityPosition_lte: String
  liquidityPosition_not: String
  liquidityPosition_not_contains: String
  liquidityPosition_not_contains_nocase: String
  liquidityPosition_not_ends_with: String
  liquidityPosition_not_ends_with_nocase: String
  liquidityPosition_not_in: [String!]
  liquidityPosition_not_starts_with: String
  liquidityPosition_not_starts_with_nocase: String
  liquidityPosition_starts_with: String
  liquidityPosition_starts_with_nocase: String
  liquidityTokenBalance: BigDecimal
  liquidityTokenBalance_gt: BigDecimal
  liquidityTokenBalance_gte: BigDecimal
  liquidityTokenBalance_in: [BigDecimal!]
  liquidityTokenBalance_lt: BigDecimal
  liquidityTokenBalance_lte: BigDecimal
  liquidityTokenBalance_not: BigDecimal
  liquidityTokenBalance_not_in: [BigDecimal!]
  liquidityTokenTotalSupply: BigDecimal
  liquidityTokenTotalSupply_gt: BigDecimal
  liquidityTokenTotalSupply_gte: BigDecimal
  liquidityTokenTotalSupply_in: [BigDecimal!]
  liquidityTokenTotalSupply_lt: BigDecimal
  liquidityTokenTotalSupply_lte: BigDecimal
  liquidityTokenTotalSupply_not: BigDecimal
  liquidityTokenTotalSupply_not_in: [BigDecimal!]
  or: [LiquidityPositionSnapshot_filter]
  pair: String
  pair_: Pair_filter
  pair_contains: String
  pair_contains_nocase: String
  pair_ends_with: String
  pair_ends_with_nocase: String
  pair_gt: String
  pair_gte: String
  pair_in: [String!]
  pair_lt: String
  pair_lte: String
  pair_not: String
  pair_not_contains: String
  pair_not_contains_nocase: String
  pair_not_ends_with: String
  pair_not_ends_with_nocase: String
  pair_not_in: [String!]
  pair_not_starts_with: String
  pair_not_starts_with_nocase: String
  pair_starts_with: String
  pair_starts_with_nocase: String
  reserve0: BigDecimal
  reserve0_gt: BigDecimal
  reserve0_gte: BigDecimal
  reserve0_in: [BigDecimal!]
  reserve0_lt: BigDecimal
  reserve0_lte: BigDecimal
  reserve0_not: BigDecimal
  reserve0_not_in: [BigDecimal!]
  reserve1: BigDecimal
  reserve1_gt: BigDecimal
  reserve1_gte: BigDecimal
  reserve1_in: [BigDecimal!]
  reserve1_lt: BigDecimal
  reserve1_lte: BigDecimal
  reserve1_not: BigDecimal
  reserve1_not_in: [BigDecimal!]
  reserveUSD: BigDecimal
  reserveUSD_gt: BigDecimal
  reserveUSD_gte: BigDecimal
  reserveUSD_in: [BigDecimal!]
  reserveUSD_lt: BigDecimal
  reserveUSD_lte: BigDecimal
  reserveUSD_not: BigDecimal
  reserveUSD_not_in: [BigDecimal!]
  timestamp: Int
  timestamp_gt: Int
  timestamp_gte: Int
  timestamp_in: [Int!]
  timestamp_lt: Int
  timestamp_lte: Int
  timestamp_not: Int
  timestamp_not_in: [Int!]
  token0PriceUSD: BigDecimal
  token0PriceUSD_gt: BigDecimal
  token0PriceUSD_gte: BigDecimal
  token0PriceUSD_in: [BigDecimal!]
  token0PriceUSD_lt: BigDecimal
  token0PriceUSD_lte: BigDecimal
  token0PriceUSD_not: BigDecimal
  token0PriceUSD_not_in: [BigDecimal!]
  token1PriceUSD: BigDecimal
  token1PriceUSD_gt: BigDecimal
  token1PriceUSD_gte: BigDecimal
  token1PriceUSD_in: [BigDecimal!]
  token1PriceUSD_lt: BigDecimal
  token1PriceUSD_lte: BigDecimal
  token1PriceUSD_not: BigDecimal
  token1PriceUSD_not_in: [BigDecimal!]
  user: String
  user_: User_filter
  user_contains: String
  user_contains_nocase: String
  user_ends_with: String
  user_ends_with_nocase: String
  user_gt: String
  user_gte: String
  user_in: [String!]
  user_lt: String
  user_lte: String
  user_not: String
  user_not_contains: String
  user_not_contains_nocase: String
  user_not_ends_with: String
  user_not_ends_with_nocase: String
  user_not_in: [String!]
  user_not_starts_with: String
  user_not_starts_with_nocase: String
  user_starts_with: String
  user_starts_with_nocase: String
}

enum LiquidityPositionSnapshot_orderBy {
  block
  id
  liquidityPosition
  liquidityPosition__id
  liquidityPosition__liquidityTokenBalance
  liquidityTokenBalance
  liquidityTokenTotalSupply
  pair
  pair__createdAtBlockNumber
  pair__createdAtTimestamp
  pair__id
  pair__liquidityProviderCount
  pair__reserve0
  pair__reserve1
  pair__reserveETH
  pair__reserveUSD
  pair__stable
  pair__token0Price
  pair__token1Price
  pair__totalSupply
  pair__trackedReserveETH
  pair__txCount
  pair__untrackedVolumeUSD
  pair__volumeToken0
  pair__volumeToken1
  pair__volumeUSD
  reserve0
  reserve1
  reserveUSD
  timestamp
  token0PriceUSD
  token1PriceUSD
  user
  user__id
  user__usdSwapped
}

input LiquidityPosition_filter {
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [LiquidityPosition_filter]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  liquidityTokenBalance: BigDecimal
  liquidityTokenBalance_gt: BigDecimal
  liquidityTokenBalance_gte: BigDecimal
  liquidityTokenBalance_in: [BigDecimal!]
  liquidityTokenBalance_lt: BigDecimal
  liquidityTokenBalance_lte: BigDecimal
  liquidityTokenBalance_not: BigDecimal
  liquidityTokenBalance_not_in: [BigDecimal!]
  or: [LiquidityPosition_filter]
  pair: String
  pair_: Pair_filter
  pair_contains: String
  pair_contains_nocase: String
  pair_ends_with: String
  pair_ends_with_nocase: String
  pair_gt: String
  pair_gte: String
  pair_in: [String!]
  pair_lt: String
  pair_lte: String
  pair_not: String
  pair_not_contains: String
  pair_not_contains_nocase: String
  pair_not_ends_with: String
  pair_not_ends_with_nocase: String
  pair_not_in: [String!]
  pair_not_starts_with: String
  pair_not_starts_with_nocase: String
  pair_starts_with: String
  pair_starts_with_nocase: String
  user: String
  user_: User_filter
  user_contains: String
  user_contains_nocase: String
  user_ends_with: String
  user_ends_with_nocase: String
  user_gt: String
  user_gte: String
  user_in: [String!]
  user_lt: String
  user_lte: String
  user_not: String
  user_not_contains: String
  user_not_contains_nocase: String
  user_not_ends_with: String
  user_not_ends_with_nocase: String
  user_not_in: [String!]
  user_not_starts_with: String
  user_not_starts_with_nocase: String
  user_starts_with: String
  user_starts_with_nocase: String
}

enum LiquidityPosition_orderBy {
  id
  liquidityTokenBalance
  pair
  pair__createdAtBlockNumber
  pair__createdAtTimestamp
  pair__id
  pair__liquidityProviderCount
  pair__reserve0
  pair__reserve1
  pair__reserveETH
  pair__reserveUSD
  pair__stable
  pair__token0Price
  pair__token1Price
  pair__totalSupply
  pair__trackedReserveETH
  pair__txCount
  pair__untrackedVolumeUSD
  pair__volumeToken0
  pair__volumeToken1
  pair__volumeUSD
  user
  user__id
  user__usdSwapped
}

type Mint {
  amount0: BigDecimal
  amount1: BigDecimal
  amountUSD: BigDecimal
  feeLiquidity: BigDecimal
  feeTo: Bytes
  id: ID!
  liquidity: BigDecimal!
  logIndex: BigInt
  pair: Pair!
  sender: Bytes
  timestamp: BigInt!
  to: Bytes!
  transaction: Transaction!
}

input Mint_filter {
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  amount0: BigDecimal
  amount0_gt: BigDecimal
  amount0_gte: BigDecimal
  amount0_in: [BigDecimal!]
  amount0_lt: BigDecimal
  amount0_lte: BigDecimal
  amount0_not: BigDecimal
  amount0_not_in: [BigDecimal!]
  amount1: BigDecimal
  amount1_gt: BigDecimal
  amount1_gte: BigDecimal
  amount1_in: [BigDecimal!]
  amount1_lt: BigDecimal
  amount1_lte: BigDecimal
  amount1_not: BigDecimal
  amount1_not_in: [BigDecimal!]
  amountUSD: BigDecimal
  amountUSD_gt: BigDecimal
  amountUSD_gte: BigDecimal
  amountUSD_in: [BigDecimal!]
  amountUSD_lt: BigDecimal
  amountUSD_lte: BigDecimal
  amountUSD_not: BigDecimal
  amountUSD_not_in: [BigDecimal!]
  and: [Mint_filter]
  feeLiquidity: BigDecimal
  feeLiquidity_gt: BigDecimal
  feeLiquidity_gte: BigDecimal
  feeLiquidity_in: [BigDecimal!]
  feeLiquidity_lt: BigDecimal
  feeLiquidity_lte: BigDecimal
  feeLiquidity_not: BigDecimal
  feeLiquidity_not_in: [BigDecimal!]
  feeTo: Bytes
  feeTo_contains: Bytes
  feeTo_gt: Bytes
  feeTo_gte: Bytes
  feeTo_in: [Bytes!]
  feeTo_lt: Bytes
  feeTo_lte: Bytes
  feeTo_not: Bytes
  feeTo_not_contains: Bytes
  feeTo_not_in: [Bytes!]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  liquidity: BigDecimal
  liquidity_gt: BigDecimal
  liquidity_gte: BigDecimal
  liquidity_in: [BigDecimal!]
  liquidity_lt: BigDecimal
  liquidity_lte: BigDecimal
  liquidity_not: BigDecimal
  liquidity_not_in: [BigDecimal!]
  logIndex: BigInt
  logIndex_gt: BigInt
  logIndex_gte: BigInt
  logIndex_in: [BigInt!]
  logIndex_lt: BigInt
  logIndex_lte: BigInt
  logIndex_not: BigInt
  logIndex_not_in: [BigInt!]
  or: [Mint_filter]
  pair: String
  pair_: Pair_filter
  pair_contains: String
  pair_contains_nocase: String
  pair_ends_with: String
  pair_ends_with_nocase: String
  pair_gt: String
  pair_gte: String
  pair_in: [String!]
  pair_lt: String
  pair_lte: String
  pair_not: String
  pair_not_contains: String
  pair_not_contains_nocase: String
  pair_not_ends_with: String
  pair_not_ends_with_nocase: String
  pair_not_in: [String!]
  pair_not_starts_with: String
  pair_not_starts_with_nocase: String
  pair_starts_with: String
  pair_starts_with_nocase: String
  sender: Bytes
  sender_contains: Bytes
  sender_gt: Bytes
  sender_gte: Bytes
  sender_in: [Bytes!]
  sender_lt: Bytes
  sender_lte: Bytes
  sender_not: Bytes
  sender_not_contains: Bytes
  sender_not_in: [Bytes!]
  timestamp: BigInt
  timestamp_gt: BigInt
  timestamp_gte: BigInt
  timestamp_in: [BigInt!]
  timestamp_lt: BigInt
  timestamp_lte: BigInt
  timestamp_not: BigInt
  timestamp_not_in: [BigInt!]
  to: Bytes
  to_contains: Bytes
  to_gt: Bytes
  to_gte: Bytes
  to_in: [Bytes!]
  to_lt: Bytes
  to_lte: Bytes
  to_not: Bytes
  to_not_contains: Bytes
  to_not_in: [Bytes!]
  transaction: String
  transaction_: Transaction_filter
  transaction_contains: String
  transaction_contains_nocase: String
  transaction_ends_with: String
  transaction_ends_with_nocase: String
  transaction_gt: String
  transaction_gte: String
  transaction_in: [String!]
  transaction_lt: String
  transaction_lte: String
  transaction_not: String
  transaction_not_contains: String
  transaction_not_contains_nocase: String
  transaction_not_ends_with: String
  transaction_not_ends_with_nocase: String
  transaction_not_in: [String!]
  transaction_not_starts_with: String
  transaction_not_starts_with_nocase: String
  transaction_starts_with: String
  transaction_starts_with_nocase: String
}

enum Mint_orderBy {
  amount0
  amount1
  amountUSD
  feeLiquidity
  feeTo
  id
  liquidity
  logIndex
  pair
  pair__createdAtBlockNumber
  pair__createdAtTimestamp
  pair__id
  pair__liquidityProviderCount
  pair__reserve0
  pair__reserve1
  pair__reserveETH
  pair__reserveUSD
  pair__stable
  pair__token0Price
  pair__token1Price
  pair__totalSupply
  pair__trackedReserveETH
  pair__txCount
  pair__untrackedVolumeUSD
  pair__volumeToken0
  pair__volumeToken1
  pair__volumeUSD
  sender
  timestamp
  to
  transaction
  transaction__blockNumber
  transaction__id
  transaction__timestamp
}

"""Defines the order direction, either ascending or descending"""
enum OrderDirection {
  asc
  desc
}

type Pair {
  burns(first: Int = 100, orderBy: Burn_orderBy, orderDirection: OrderDirection, skip: Int = 0, where: Burn_filter): [Burn!]!
  createdAtBlockNumber: BigInt!
  createdAtTimestamp: BigInt!
  id: ID!
  liquidityPositionSnapshots(first: Int = 100, orderBy: LiquidityPositionSnapshot_orderBy, orderDirection: OrderDirection, skip: Int = 0, where: LiquidityPositionSnapshot_filter): [LiquidityPositionSnapshot!]!
  liquidityPositions(first: Int = 100, orderBy: LiquidityPosition_orderBy, orderDirection: OrderDirection, skip: Int = 0, where: LiquidityPosition_filter): [LiquidityPosition!]!
  liquidityProviderCount: BigInt!
  mints(first: Int = 100, orderBy: Mint_orderBy, orderDirection: OrderDirection, skip: Int = 0, where: Mint_filter): [Mint!]!
  pairHourData(first: Int = 100, orderBy: PairHourData_orderBy, orderDirection: OrderDirection, skip: Int = 0, where: PairHourData_filter): [PairHourData!]!
  reserve0: BigDecimal!
  reserve1: BigDecimal!
  reserveETH: BigDecimal!
  reserveUSD: BigDecimal!
  stable: Boolean!
  swaps(first: Int = 100, orderBy: Swap_orderBy, orderDirection: OrderDirection, skip: Int = 0, where: Swap_filter): [Swap!]!
  token0: Token!
  token0Price: BigDecimal!
  token1: Token!
  token1Price: BigDecimal!
  totalSupply: BigDecimal!
  trackedReserveETH: BigDecimal!
  txCount: BigInt!
  untrackedVolumeUSD: BigDecimal!
  volumeToken0: BigDecimal!
  volumeToken1: BigDecimal!
  volumeUSD: BigDecimal!
}

type PairDayData {
  dailyTxns: BigInt!
  dailyVolumeToken0: BigDecimal!
  dailyVolumeToken1: BigDecimal!
  dailyVolumeUSD: BigDecimal!
  date: Int!
  id: ID!
  pairAddress: Bytes!
  reserve0: BigDecimal!
  reserve1: BigDecimal!
  reserveUSD: BigDecimal!
  token0: Token!
  token1: Token!
  totalSupply: BigDecimal!
}

input PairDayData_filter {
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [PairDayData_filter]
  dailyTxns: BigInt
  dailyTxns_gt: BigInt
  dailyTxns_gte: BigInt
  dailyTxns_in: [BigInt!]
  dailyTxns_lt: BigInt
  dailyTxns_lte: BigInt
  dailyTxns_not: BigInt
  dailyTxns_not_in: [BigInt!]
  dailyVolumeToken0: BigDecimal
  dailyVolumeToken0_gt: BigDecimal
  dailyVolumeToken0_gte: BigDecimal
  dailyVolumeToken0_in: [BigDecimal!]
  dailyVolumeToken0_lt: BigDecimal
  dailyVolumeToken0_lte: BigDecimal
  dailyVolumeToken0_not: BigDecimal
  dailyVolumeToken0_not_in: [BigDecimal!]
  dailyVolumeToken1: BigDecimal
  dailyVolumeToken1_gt: BigDecimal
  dailyVolumeToken1_gte: BigDecimal
  dailyVolumeToken1_in: [BigDecimal!]
  dailyVolumeToken1_lt: BigDecimal
  dailyVolumeToken1_lte: BigDecimal
  dailyVolumeToken1_not: BigDecimal
  dailyVolumeToken1_not_in: [BigDecimal!]
  dailyVolumeUSD: BigDecimal
  dailyVolumeUSD_gt: BigDecimal
  dailyVolumeUSD_gte: BigDecimal
  dailyVolumeUSD_in: [BigDecimal!]
  dailyVolumeUSD_lt: BigDecimal
  dailyVolumeUSD_lte: BigDecimal
  dailyVolumeUSD_not: BigDecimal
  dailyVolumeUSD_not_in: [BigDecimal!]
  date: Int
  date_gt: Int
  date_gte: Int
  date_in: [Int!]
  date_lt: Int
  date_lte: Int
  date_not: Int
  date_not_in: [Int!]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  or: [PairDayData_filter]
  pairAddress: Bytes
  pairAddress_contains: Bytes
  pairAddress_gt: Bytes
  pairAddress_gte: Bytes
  pairAddress_in: [Bytes!]
  pairAddress_lt: Bytes
  pairAddress_lte: Bytes
  pairAddress_not: Bytes
  pairAddress_not_contains: Bytes
  pairAddress_not_in: [Bytes!]
  reserve0: BigDecimal
  reserve0_gt: BigDecimal
  reserve0_gte: BigDecimal
  reserve0_in: [BigDecimal!]
  reserve0_lt: BigDecimal
  reserve0_lte: BigDecimal
  reserve0_not: BigDecimal
  reserve0_not_in: [BigDecimal!]
  reserve1: BigDecimal
  reserve1_gt: BigDecimal
  reserve1_gte: BigDecimal
  reserve1_in: [BigDecimal!]
  reserve1_lt: BigDecimal
  reserve1_lte: BigDecimal
  reserve1_not: BigDecimal
  reserve1_not_in: [BigDecimal!]
  reserveUSD: BigDecimal
  reserveUSD_gt: BigDecimal
  reserveUSD_gte: BigDecimal
  reserveUSD_in: [BigDecimal!]
  reserveUSD_lt: BigDecimal
  reserveUSD_lte: BigDecimal
  reserveUSD_not: BigDecimal
  reserveUSD_not_in: [BigDecimal!]
  token0: String
  token0_: Token_filter
  token0_contains: String
  token0_contains_nocase: String
  token0_ends_with: String
  token0_ends_with_nocase: String
  token0_gt: String
  token0_gte: String
  token0_in: [String!]
  token0_lt: String
  token0_lte: String
  token0_not: String
  token0_not_contains: String
  token0_not_contains_nocase: String
  token0_not_ends_with: String
  token0_not_ends_with_nocase: String
  token0_not_in: [String!]
  token0_not_starts_with: String
  token0_not_starts_with_nocase: String
  token0_starts_with: String
  token0_starts_with_nocase: String
  token1: String
  token1_: Token_filter
  token1_contains: String
  token1_contains_nocase: String
  token1_ends_with: String
  token1_ends_with_nocase: String
  token1_gt: String
  token1_gte: String
  token1_in: [String!]
  token1_lt: String
  token1_lte: String
  token1_not: String
  token1_not_contains: String
  token1_not_contains_nocase: String
  token1_not_ends_with: String
  token1_not_ends_with_nocase: String
  token1_not_in: [String!]
  token1_not_starts_with: String
  token1_not_starts_with_nocase: String
  token1_starts_with: String
  token1_starts_with_nocase: String
  totalSupply: BigDecimal
  totalSupply_gt: BigDecimal
  totalSupply_gte: BigDecimal
  totalSupply_in: [BigDecimal!]
  totalSupply_lt: BigDecimal
  totalSupply_lte: BigDecimal
  totalSupply_not: BigDecimal
  totalSupply_not_in: [BigDecimal!]
}

enum PairDayData_orderBy {
  dailyTxns
  dailyVolumeToken0
  dailyVolumeToken1
  dailyVolumeUSD
  date
  id
  pairAddress
  reserve0
  reserve1
  reserveUSD
  token0
  token0__decimals
  token0__derivedETH
  token0__id
  token0__name
  token0__symbol
  token0__totalLiquidity
  token0__totalSupply
  token0__tradeVolume
  token0__tradeVolumeUSD
  token0__txCount
  token0__untrackedVolumeUSD
  token1
  token1__decimals
  token1__derivedETH
  token1__id
  token1__name
  token1__symbol
  token1__totalLiquidity
  token1__totalSupply
  token1__tradeVolume
  token1__tradeVolumeUSD
  token1__txCount
  token1__untrackedVolumeUSD
  totalSupply
}

type PairHourData {
  hourStartUnix: Int!
  hourlyTxns: BigInt!
  hourlyVolumeToken0: BigDecimal!
  hourlyVolumeToken1: BigDecimal!
  hourlyVolumeUSD: BigDecimal!
  id: ID!
  pair: Pair!
  reserve0: BigDecimal!
  reserve1: BigDecimal!
  reserveUSD: BigDecimal!
  totalSupply: BigDecimal!
}

input PairHourData_filter {
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [PairHourData_filter]
  hourStartUnix: Int
  hourStartUnix_gt: Int
  hourStartUnix_gte: Int
  hourStartUnix_in: [Int!]
  hourStartUnix_lt: Int
  hourStartUnix_lte: Int
  hourStartUnix_not: Int
  hourStartUnix_not_in: [Int!]
  hourlyTxns: BigInt
  hourlyTxns_gt: BigInt
  hourlyTxns_gte: BigInt
  hourlyTxns_in: [BigInt!]
  hourlyTxns_lt: BigInt
  hourlyTxns_lte: BigInt
  hourlyTxns_not: BigInt
  hourlyTxns_not_in: [BigInt!]
  hourlyVolumeToken0: BigDecimal
  hourlyVolumeToken0_gt: BigDecimal
  hourlyVolumeToken0_gte: BigDecimal
  hourlyVolumeToken0_in: [BigDecimal!]
  hourlyVolumeToken0_lt: BigDecimal
  hourlyVolumeToken0_lte: BigDecimal
  hourlyVolumeToken0_not: BigDecimal
  hourlyVolumeToken0_not_in: [BigDecimal!]
  hourlyVolumeToken1: BigDecimal
  hourlyVolumeToken1_gt: BigDecimal
  hourlyVolumeToken1_gte: BigDecimal
  hourlyVolumeToken1_in: [BigDecimal!]
  hourlyVolumeToken1_lt: BigDecimal
  hourlyVolumeToken1_lte: BigDecimal
  hourlyVolumeToken1_not: BigDecimal
  hourlyVolumeToken1_not_in: [BigDecimal!]
  hourlyVolumeUSD: BigDecimal
  hourlyVolumeUSD_gt: BigDecimal
  hourlyVolumeUSD_gte: BigDecimal
  hourlyVolumeUSD_in: [BigDecimal!]
  hourlyVolumeUSD_lt: BigDecimal
  hourlyVolumeUSD_lte: BigDecimal
  hourlyVolumeUSD_not: BigDecimal
  hourlyVolumeUSD_not_in: [BigDecimal!]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  or: [PairHourData_filter]
  pair: String
  pair_: Pair_filter
  pair_contains: String
  pair_contains_nocase: String
  pair_ends_with: String
  pair_ends_with_nocase: String
  pair_gt: String
  pair_gte: String
  pair_in: [String!]
  pair_lt: String
  pair_lte: String
  pair_not: String
  pair_not_contains: String
  pair_not_contains_nocase: String
  pair_not_ends_with: String
  pair_not_ends_with_nocase: String
  pair_not_in: [String!]
  pair_not_starts_with: String
  pair_not_starts_with_nocase: String
  pair_starts_with: String
  pair_starts_with_nocase: String
  reserve0: BigDecimal
  reserve0_gt: BigDecimal
  reserve0_gte: BigDecimal
  reserve0_in: [BigDecimal!]
  reserve0_lt: BigDecimal
  reserve0_lte: BigDecimal
  reserve0_not: BigDecimal
  reserve0_not_in: [BigDecimal!]
  reserve1: BigDecimal
  reserve1_gt: BigDecimal
  reserve1_gte: BigDecimal
  reserve1_in: [BigDecimal!]
  reserve1_lt: BigDecimal
  reserve1_lte: BigDecimal
  reserve1_not: BigDecimal
  reserve1_not_in: [BigDecimal!]
  reserveUSD: BigDecimal
  reserveUSD_gt: BigDecimal
  reserveUSD_gte: BigDecimal
  reserveUSD_in: [BigDecimal!]
  reserveUSD_lt: BigDecimal
  reserveUSD_lte: BigDecimal
  reserveUSD_not: BigDecimal
  reserveUSD_not_in: [BigDecimal!]
  totalSupply: BigDecimal
  totalSupply_gt: BigDecimal
  totalSupply_gte: BigDecimal
  totalSupply_in: [BigDecimal!]
  totalSupply_lt: BigDecimal
  totalSupply_lte: BigDecimal
  totalSupply_not: BigDecimal
  totalSupply_not_in: [BigDecimal!]
}

enum PairHourData_orderBy {
  hourStartUnix
  hourlyTxns
  hourlyVolumeToken0
  hourlyVolumeToken1
  hourlyVolumeUSD
  id
  pair
  pair__createdAtBlockNumber
  pair__createdAtTimestamp
  pair__id
  pair__liquidityProviderCount
  pair__reserve0
  pair__reserve1
  pair__reserveETH
  pair__reserveUSD
  pair__stable
  pair__token0Price
  pair__token1Price
  pair__totalSupply
  pair__trackedReserveETH
  pair__txCount
  pair__untrackedVolumeUSD
  pair__volumeToken0
  pair__volumeToken1
  pair__volumeUSD
  reserve0
  reserve1
  reserveUSD
  totalSupply
}

type PairMap {
  id: ID!
  pairIds: [ID!]!
}

input PairMap_filter {
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [PairMap_filter]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  or: [PairMap_filter]
  pairIds: [ID!]
  pairIds_contains: [ID!]
  pairIds_contains_nocase: [ID!]
  pairIds_not: [ID!]
  pairIds_not_contains: [ID!]
  pairIds_not_contains_nocase: [ID!]
}

enum PairMap_orderBy {
  id
  pairIds
}

input Pair_filter {
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [Pair_filter]
  burns_: Burn_filter
  createdAtBlockNumber: BigInt
  createdAtBlockNumber_gt: BigInt
  createdAtBlockNumber_gte: BigInt
  createdAtBlockNumber_in: [BigInt!]
  createdAtBlockNumber_lt: BigInt
  createdAtBlockNumber_lte: BigInt
  createdAtBlockNumber_not: BigInt
  createdAtBlockNumber_not_in: [BigInt!]
  createdAtTimestamp: BigInt
  createdAtTimestamp_gt: BigInt
  createdAtTimestamp_gte: BigInt
  createdAtTimestamp_in: [BigInt!]
  createdAtTimestamp_lt: BigInt
  createdAtTimestamp_lte: BigInt
  createdAtTimestamp_not: BigInt
  createdAtTimestamp_not_in: [BigInt!]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  liquidityPositionSnapshots_: LiquidityPositionSnapshot_filter
  liquidityPositions_: LiquidityPosition_filter
  liquidityProviderCount: BigInt
  liquidityProviderCount_gt: BigInt
  liquidityProviderCount_gte: BigInt
  liquidityProviderCount_in: [BigInt!]
  liquidityProviderCount_lt: BigInt
  liquidityProviderCount_lte: BigInt
  liquidityProviderCount_not: BigInt
  liquidityProviderCount_not_in: [BigInt!]
  mints_: Mint_filter
  or: [Pair_filter]
  pairHourData_: PairHourData_filter
  reserve0: BigDecimal
  reserve0_gt: BigDecimal
  reserve0_gte: BigDecimal
  reserve0_in: [BigDecimal!]
  reserve0_lt: BigDecimal
  reserve0_lte: BigDecimal
  reserve0_not: BigDecimal
  reserve0_not_in: [BigDecimal!]
  reserve1: BigDecimal
  reserve1_gt: BigDecimal
  reserve1_gte: BigDecimal
  reserve1_in: [BigDecimal!]
  reserve1_lt: BigDecimal
  reserve1_lte: BigDecimal
  reserve1_not: BigDecimal
  reserve1_not_in: [BigDecimal!]
  reserveETH: BigDecimal
  reserveETH_gt: BigDecimal
  reserveETH_gte: BigDecimal
  reserveETH_in: [BigDecimal!]
  reserveETH_lt: BigDecimal
  reserveETH_lte: BigDecimal
  reserveETH_not: BigDecimal
  reserveETH_not_in: [BigDecimal!]
  reserveUSD: BigDecimal
  reserveUSD_gt: BigDecimal
  reserveUSD_gte: BigDecimal
  reserveUSD_in: [BigDecimal!]
  reserveUSD_lt: BigDecimal
  reserveUSD_lte: BigDecimal
  reserveUSD_not: BigDecimal
  reserveUSD_not_in: [BigDecimal!]
  stable: Boolean
  stable_in: [Boolean!]
  stable_not: Boolean
  stable_not_in: [Boolean!]
  swaps_: Swap_filter
  token0: String
  token0Price: BigDecimal
  token0Price_gt: BigDecimal
  token0Price_gte: BigDecimal
  token0Price_in: [BigDecimal!]
  token0Price_lt: BigDecimal
  token0Price_lte: BigDecimal
  token0Price_not: BigDecimal
  token0Price_not_in: [BigDecimal!]
  token0_: Token_filter
  token0_contains: String
  token0_contains_nocase: String
  token0_ends_with: String
  token0_ends_with_nocase: String
  token0_gt: String
  token0_gte: String
  token0_in: [String!]
  token0_lt: String
  token0_lte: String
  token0_not: String
  token0_not_contains: String
  token0_not_contains_nocase: String
  token0_not_ends_with: String
  token0_not_ends_with_nocase: String
  token0_not_in: [String!]
  token0_not_starts_with: String
  token0_not_starts_with_nocase: String
  token0_starts_with: String
  token0_starts_with_nocase: String
  token1: String
  token1Price: BigDecimal
  token1Price_gt: BigDecimal
  token1Price_gte: BigDecimal
  token1Price_in: [BigDecimal!]
  token1Price_lt: BigDecimal
  token1Price_lte: BigDecimal
  token1Price_not: BigDecimal
  token1Price_not_in: [BigDecimal!]
  token1_: Token_filter
  token1_contains: String
  token1_contains_nocase: String
  token1_ends_with: String
  token1_ends_with_nocase: String
  token1_gt: String
  token1_gte: String
  token1_in: [String!]
  token1_lt: String
  token1_lte: String
  token1_not: String
  token1_not_contains: String
  token1_not_contains_nocase: String
  token1_not_ends_with: String
  token1_not_ends_with_nocase: String
  token1_not_in: [String!]
  token1_not_starts_with: String
  token1_not_starts_with_nocase: String
  token1_starts_with: String
  token1_starts_with_nocase: String
  totalSupply: BigDecimal
  totalSupply_gt: BigDecimal
  totalSupply_gte: BigDecimal
  totalSupply_in: [BigDecimal!]
  totalSupply_lt: BigDecimal
  totalSupply_lte: BigDecimal
  totalSupply_not: BigDecimal
  totalSupply_not_in: [BigDecimal!]
  trackedReserveETH: BigDecimal
  trackedReserveETH_gt: BigDecimal
  trackedReserveETH_gte: BigDecimal
  trackedReserveETH_in: [BigDecimal!]
  trackedReserveETH_lt: BigDecimal
  trackedReserveETH_lte: BigDecimal
  trackedReserveETH_not: BigDecimal
  trackedReserveETH_not_in: [BigDecimal!]
  txCount: BigInt
  txCount_gt: BigInt
  txCount_gte: BigInt
  txCount_in: [BigInt!]
  txCount_lt: BigInt
  txCount_lte: BigInt
  txCount_not: BigInt
  txCount_not_in: [BigInt!]
  untrackedVolumeUSD: BigDecimal
  untrackedVolumeUSD_gt: BigDecimal
  untrackedVolumeUSD_gte: BigDecimal
  untrackedVolumeUSD_in: [BigDecimal!]
  untrackedVolumeUSD_lt: BigDecimal
  untrackedVolumeUSD_lte: BigDecimal
  untrackedVolumeUSD_not: BigDecimal
  untrackedVolumeUSD_not_in: [BigDecimal!]
  volumeToken0: BigDecimal
  volumeToken0_gt: BigDecimal
  volumeToken0_gte: BigDecimal
  volumeToken0_in: [BigDecimal!]
  volumeToken0_lt: BigDecimal
  volumeToken0_lte: BigDecimal
  volumeToken0_not: BigDecimal
  volumeToken0_not_in: [BigDecimal!]
  volumeToken1: BigDecimal
  volumeToken1_gt: BigDecimal
  volumeToken1_gte: BigDecimal
  volumeToken1_in: [BigDecimal!]
  volumeToken1_lt: BigDecimal
  volumeToken1_lte: BigDecimal
  volumeToken1_not: BigDecimal
  volumeToken1_not_in: [BigDecimal!]
  volumeUSD: BigDecimal
  volumeUSD_gt: BigDecimal
  volumeUSD_gte: BigDecimal
  volumeUSD_in: [BigDecimal!]
  volumeUSD_lt: BigDecimal
  volumeUSD_lte: BigDecimal
  volumeUSD_not: BigDecimal
  volumeUSD_not_in: [BigDecimal!]
}

enum Pair_orderBy {
  burns
  createdAtBlockNumber
  createdAtTimestamp
  id
  liquidityPositionSnapshots
  liquidityPositions
  liquidityProviderCount
  mints
  pairHourData
  reserve0
  reserve1
  reserveETH
  reserveUSD
  stable
  swaps
  token0
  token0Price
  token0__decimals
  token0__derivedETH
  token0__id
  token0__name
  token0__symbol
  token0__totalLiquidity
  token0__totalSupply
  token0__tradeVolume
  token0__tradeVolumeUSD
  token0__txCount
  token0__untrackedVolumeUSD
  token1
  token1Price
  token1__decimals
  token1__derivedETH
  token1__id
  token1__name
  token1__symbol
  token1__totalLiquidity
  token1__totalSupply
  token1__tradeVolume
  token1__tradeVolumeUSD
  token1__txCount
  token1__untrackedVolumeUSD
  totalSupply
  trackedReserveETH
  txCount
  untrackedVolumeUSD
  volumeToken0
  volumeToken1
  volumeUSD
}

type Query {
  """Access to subgraph metadata"""
  _meta(block: Block_height): _Meta_
  bundle(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Bundle
  bundles(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: Bundle_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: Bundle_filter
  ): [Bundle!]!
  burn(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Burn
  burns(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: Burn_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: Burn_filter
  ): [Burn!]!
  liquidityPosition(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): LiquidityPosition
  liquidityPositionSnapshot(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): LiquidityPositionSnapshot
  liquidityPositionSnapshots(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: LiquidityPositionSnapshot_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: LiquidityPositionSnapshot_filter
  ): [LiquidityPositionSnapshot!]!
  liquidityPositions(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: LiquidityPosition_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: LiquidityPosition_filter
  ): [LiquidityPosition!]!
  mint(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Mint
  mints(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: Mint_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: Mint_filter
  ): [Mint!]!
  pair(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Pair
  pairDayData(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): PairDayData
  pairDayDatas(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: PairDayData_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: PairDayData_filter
  ): [PairDayData!]!
  pairHourData(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): PairHourData
  pairHourDatas(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: PairHourData_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: PairHourData_filter
  ): [PairHourData!]!
  pairMap(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): PairMap
  pairMaps(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: PairMap_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: PairMap_filter
  ): [PairMap!]!
  pairs(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: Pair_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: Pair_filter
  ): [Pair!]!
  swap(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Swap
  swaps(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: Swap_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: Swap_filter
  ): [Swap!]!
  token(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Token
  tokenDayData(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): TokenDayData
  tokenDayDatas(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: TokenDayData_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: TokenDayData_filter
  ): [TokenDayData!]!
  tokens(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: Token_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: Token_filter
  ): [Token!]!
  transaction(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Transaction
  transactions(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: Transaction_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: Transaction_filter
  ): [Transaction!]!
  uniswapDayData(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): UniswapDayData
  uniswapDayDatas(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: UniswapDayData_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: UniswapDayData_filter
  ): [UniswapDayData!]!
  uniswapFactories(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: UniswapFactory_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: UniswapFactory_filter
  ): [UniswapFactory!]!
  uniswapFactory(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): UniswapFactory
  user(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): User
  users(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: User_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: User_filter
  ): [User!]!
}

type Subscription {
  """Access to subgraph metadata"""
  _meta(block: Block_height): _Meta_
  bundle(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Bundle
  bundles(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: Bundle_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: Bundle_filter
  ): [Bundle!]!
  burn(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Burn
  burns(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: Burn_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: Burn_filter
  ): [Burn!]!
  liquidityPosition(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): LiquidityPosition
  liquidityPositionSnapshot(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): LiquidityPositionSnapshot
  liquidityPositionSnapshots(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: LiquidityPositionSnapshot_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: LiquidityPositionSnapshot_filter
  ): [LiquidityPositionSnapshot!]!
  liquidityPositions(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: LiquidityPosition_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: LiquidityPosition_filter
  ): [LiquidityPosition!]!
  mint(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Mint
  mints(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: Mint_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: Mint_filter
  ): [Mint!]!
  pair(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Pair
  pairDayData(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): PairDayData
  pairDayDatas(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: PairDayData_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: PairDayData_filter
  ): [PairDayData!]!
  pairHourData(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): PairHourData
  pairHourDatas(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: PairHourData_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: PairHourData_filter
  ): [PairHourData!]!
  pairMap(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): PairMap
  pairMaps(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: PairMap_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: PairMap_filter
  ): [PairMap!]!
  pairs(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: Pair_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: Pair_filter
  ): [Pair!]!
  swap(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Swap
  swaps(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: Swap_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: Swap_filter
  ): [Swap!]!
  token(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Token
  tokenDayData(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): TokenDayData
  tokenDayDatas(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: TokenDayData_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: TokenDayData_filter
  ): [TokenDayData!]!
  tokens(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: Token_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: Token_filter
  ): [Token!]!
  transaction(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Transaction
  transactions(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: Transaction_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: Transaction_filter
  ): [Transaction!]!
  uniswapDayData(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): UniswapDayData
  uniswapDayDatas(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: UniswapDayData_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: UniswapDayData_filter
  ): [UniswapDayData!]!
  uniswapFactories(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: UniswapFactory_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: UniswapFactory_filter
  ): [UniswapFactory!]!
  uniswapFactory(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): UniswapFactory
  user(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): User
  users(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: User_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: User_filter
  ): [User!]!
}

type Swap {
  amount0In: BigDecimal!
  amount0Out: BigDecimal!
  amount1In: BigDecimal!
  amount1Out: BigDecimal!
  amountUSD: BigDecimal!
  from: Bytes!
  id: ID!
  logIndex: BigInt
  pair: Pair!
  sender: Bytes!
  timestamp: BigInt!
  to: Bytes!
  transaction: Transaction!
}

input Swap_filter {
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  amount0In: BigDecimal
  amount0In_gt: BigDecimal
  amount0In_gte: BigDecimal
  amount0In_in: [BigDecimal!]
  amount0In_lt: BigDecimal
  amount0In_lte: BigDecimal
  amount0In_not: BigDecimal
  amount0In_not_in: [BigDecimal!]
  amount0Out: BigDecimal
  amount0Out_gt: BigDecimal
  amount0Out_gte: BigDecimal
  amount0Out_in: [BigDecimal!]
  amount0Out_lt: BigDecimal
  amount0Out_lte: BigDecimal
  amount0Out_not: BigDecimal
  amount0Out_not_in: [BigDecimal!]
  amount1In: BigDecimal
  amount1In_gt: BigDecimal
  amount1In_gte: BigDecimal
  amount1In_in: [BigDecimal!]
  amount1In_lt: BigDecimal
  amount1In_lte: BigDecimal
  amount1In_not: BigDecimal
  amount1In_not_in: [BigDecimal!]
  amount1Out: BigDecimal
  amount1Out_gt: BigDecimal
  amount1Out_gte: BigDecimal
  amount1Out_in: [BigDecimal!]
  amount1Out_lt: BigDecimal
  amount1Out_lte: BigDecimal
  amount1Out_not: BigDecimal
  amount1Out_not_in: [BigDecimal!]
  amountUSD: BigDecimal
  amountUSD_gt: BigDecimal
  amountUSD_gte: BigDecimal
  amountUSD_in: [BigDecimal!]
  amountUSD_lt: BigDecimal
  amountUSD_lte: BigDecimal
  amountUSD_not: BigDecimal
  amountUSD_not_in: [BigDecimal!]
  and: [Swap_filter]
  from: Bytes
  from_contains: Bytes
  from_gt: Bytes
  from_gte: Bytes
  from_in: [Bytes!]
  from_lt: Bytes
  from_lte: Bytes
  from_not: Bytes
  from_not_contains: Bytes
  from_not_in: [Bytes!]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  logIndex: BigInt
  logIndex_gt: BigInt
  logIndex_gte: BigInt
  logIndex_in: [BigInt!]
  logIndex_lt: BigInt
  logIndex_lte: BigInt
  logIndex_not: BigInt
  logIndex_not_in: [BigInt!]
  or: [Swap_filter]
  pair: String
  pair_: Pair_filter
  pair_contains: String
  pair_contains_nocase: String
  pair_ends_with: String
  pair_ends_with_nocase: String
  pair_gt: String
  pair_gte: String
  pair_in: [String!]
  pair_lt: String
  pair_lte: String
  pair_not: String
  pair_not_contains: String
  pair_not_contains_nocase: String
  pair_not_ends_with: String
  pair_not_ends_with_nocase: String
  pair_not_in: [String!]
  pair_not_starts_with: String
  pair_not_starts_with_nocase: String
  pair_starts_with: String
  pair_starts_with_nocase: String
  sender: Bytes
  sender_contains: Bytes
  sender_gt: Bytes
  sender_gte: Bytes
  sender_in: [Bytes!]
  sender_lt: Bytes
  sender_lte: Bytes
  sender_not: Bytes
  sender_not_contains: Bytes
  sender_not_in: [Bytes!]
  timestamp: BigInt
  timestamp_gt: BigInt
  timestamp_gte: BigInt
  timestamp_in: [BigInt!]
  timestamp_lt: BigInt
  timestamp_lte: BigInt
  timestamp_not: BigInt
  timestamp_not_in: [BigInt!]
  to: Bytes
  to_contains: Bytes
  to_gt: Bytes
  to_gte: Bytes
  to_in: [Bytes!]
  to_lt: Bytes
  to_lte: Bytes
  to_not: Bytes
  to_not_contains: Bytes
  to_not_in: [Bytes!]
  transaction: String
  transaction_: Transaction_filter
  transaction_contains: String
  transaction_contains_nocase: String
  transaction_ends_with: String
  transaction_ends_with_nocase: String
  transaction_gt: String
  transaction_gte: String
  transaction_in: [String!]
  transaction_lt: String
  transaction_lte: String
  transaction_not: String
  transaction_not_contains: String
  transaction_not_contains_nocase: String
  transaction_not_ends_with: String
  transaction_not_ends_with_nocase: String
  transaction_not_in: [String!]
  transaction_not_starts_with: String
  transaction_not_starts_with_nocase: String
  transaction_starts_with: String
  transaction_starts_with_nocase: String
}

enum Swap_orderBy {
  amount0In
  amount0Out
  amount1In
  amount1Out
  amountUSD
  from
  id
  logIndex
  pair
  pair__createdAtBlockNumber
  pair__createdAtTimestamp
  pair__id
  pair__liquidityProviderCount
  pair__reserve0
  pair__reserve1
  pair__reserveETH
  pair__reserveUSD
  pair__stable
  pair__token0Price
  pair__token1Price
  pair__totalSupply
  pair__trackedReserveETH
  pair__txCount
  pair__untrackedVolumeUSD
  pair__volumeToken0
  pair__volumeToken1
  pair__volumeUSD
  sender
  timestamp
  to
  transaction
  transaction__blockNumber
  transaction__id
  transaction__timestamp
}

type Token {
  decimals: BigInt!
  derivedETH: BigDecimal!
  id: ID!
  name: String!
  pairBase(first: Int = 100, orderBy: Pair_orderBy, orderDirection: OrderDirection, skip: Int = 0, where: Pair_filter): [Pair!]!
  pairDayDataBase(first: Int = 100, orderBy: PairDayData_orderBy, orderDirection: OrderDirection, skip: Int = 0, where: PairDayData_filter): [PairDayData!]!
  pairDayDataQuote(first: Int = 100, orderBy: PairDayData_orderBy, orderDirection: OrderDirection, skip: Int = 0, where: PairDayData_filter): [PairDayData!]!
  pairQuote(first: Int = 100, orderBy: Pair_orderBy, orderDirection: OrderDirection, skip: Int = 0, where: Pair_filter): [Pair!]!
  symbol: String!
  tokenDayData(first: Int = 100, orderBy: TokenDayData_orderBy, orderDirection: OrderDirection, skip: Int = 0, where: TokenDayData_filter): [TokenDayData!]!
  totalLiquidity: BigDecimal!
  totalSupply: BigInt!
  tradeVolume: BigDecimal!
  tradeVolumeUSD: BigDecimal!
  txCount: BigInt!
  untrackedVolumeUSD: BigDecimal!
}

type TokenDayData {
  dailyTxns: BigInt!
  dailyVolumeETH: BigDecimal!
  dailyVolumeToken: BigDecimal!
  dailyVolumeUSD: BigDecimal!
  date: Int!
  id: ID!
  priceUSD: BigDecimal!
  token: Token!
  totalLiquidityETH: BigDecimal!
  totalLiquidityToken: BigDecimal!
  totalLiquidityUSD: BigDecimal!
}

input TokenDayData_filter {
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [TokenDayData_filter]
  dailyTxns: BigInt
  dailyTxns_gt: BigInt
  dailyTxns_gte: BigInt
  dailyTxns_in: [BigInt!]
  dailyTxns_lt: BigInt
  dailyTxns_lte: BigInt
  dailyTxns_not: BigInt
  dailyTxns_not_in: [BigInt!]
  dailyVolumeETH: BigDecimal
  dailyVolumeETH_gt: BigDecimal
  dailyVolumeETH_gte: BigDecimal
  dailyVolumeETH_in: [BigDecimal!]
  dailyVolumeETH_lt: BigDecimal
  dailyVolumeETH_lte: BigDecimal
  dailyVolumeETH_not: BigDecimal
  dailyVolumeETH_not_in: [BigDecimal!]
  dailyVolumeToken: BigDecimal
  dailyVolumeToken_gt: BigDecimal
  dailyVolumeToken_gte: BigDecimal
  dailyVolumeToken_in: [BigDecimal!]
  dailyVolumeToken_lt: BigDecimal
  dailyVolumeToken_lte: BigDecimal
  dailyVolumeToken_not: BigDecimal
  dailyVolumeToken_not_in: [BigDecimal!]
  dailyVolumeUSD: BigDecimal
  dailyVolumeUSD_gt: BigDecimal
  dailyVolumeUSD_gte: BigDecimal
  dailyVolumeUSD_in: [BigDecimal!]
  dailyVolumeUSD_lt: BigDecimal
  dailyVolumeUSD_lte: BigDecimal
  dailyVolumeUSD_not: BigDecimal
  dailyVolumeUSD_not_in: [BigDecimal!]
  date: Int
  date_gt: Int
  date_gte: Int
  date_in: [Int!]
  date_lt: Int
  date_lte: Int
  date_not: Int
  date_not_in: [Int!]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  or: [TokenDayData_filter]
  priceUSD: BigDecimal
  priceUSD_gt: BigDecimal
  priceUSD_gte: BigDecimal
  priceUSD_in: [BigDecimal!]
  priceUSD_lt: BigDecimal
  priceUSD_lte: BigDecimal
  priceUSD_not: BigDecimal
  priceUSD_not_in: [BigDecimal!]
  token: String
  token_: Token_filter
  token_contains: String
  token_contains_nocase: String
  token_ends_with: String
  token_ends_with_nocase: String
  token_gt: String
  token_gte: String
  token_in: [String!]
  token_lt: String
  token_lte: String
  token_not: String
  token_not_contains: String
  token_not_contains_nocase: String
  token_not_ends_with: String
  token_not_ends_with_nocase: String
  token_not_in: [String!]
  token_not_starts_with: String
  token_not_starts_with_nocase: String
  token_starts_with: String
  token_starts_with_nocase: String
  totalLiquidityETH: BigDecimal
  totalLiquidityETH_gt: BigDecimal
  totalLiquidityETH_gte: BigDecimal
  totalLiquidityETH_in: [BigDecimal!]
  totalLiquidityETH_lt: BigDecimal
  totalLiquidityETH_lte: BigDecimal
  totalLiquidityETH_not: BigDecimal
  totalLiquidityETH_not_in: [BigDecimal!]
  totalLiquidityToken: BigDecimal
  totalLiquidityToken_gt: BigDecimal
  totalLiquidityToken_gte: BigDecimal
  totalLiquidityToken_in: [BigDecimal!]
  totalLiquidityToken_lt: BigDecimal
  totalLiquidityToken_lte: BigDecimal
  totalLiquidityToken_not: BigDecimal
  totalLiquidityToken_not_in: [BigDecimal!]
  totalLiquidityUSD: BigDecimal
  totalLiquidityUSD_gt: BigDecimal
  totalLiquidityUSD_gte: BigDecimal
  totalLiquidityUSD_in: [BigDecimal!]
  totalLiquidityUSD_lt: BigDecimal
  totalLiquidityUSD_lte: BigDecimal
  totalLiquidityUSD_not: BigDecimal
  totalLiquidityUSD_not_in: [BigDecimal!]
}

enum TokenDayData_orderBy {
  dailyTxns
  dailyVolumeETH
  dailyVolumeToken
  dailyVolumeUSD
  date
  id
  priceUSD
  token
  token__decimals
  token__derivedETH
  token__id
  token__name
  token__symbol
  token__totalLiquidity
  token__totalSupply
  token__tradeVolume
  token__tradeVolumeUSD
  token__txCount
  token__untrackedVolumeUSD
  totalLiquidityETH
  totalLiquidityToken
  totalLiquidityUSD
}

input Token_filter {
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [Token_filter]
  decimals: BigInt
  decimals_gt: BigInt
  decimals_gte: BigInt
  decimals_in: [BigInt!]
  decimals_lt: BigInt
  decimals_lte: BigInt
  decimals_not: BigInt
  decimals_not_in: [BigInt!]
  derivedETH: BigDecimal
  derivedETH_gt: BigDecimal
  derivedETH_gte: BigDecimal
  derivedETH_in: [BigDecimal!]
  derivedETH_lt: BigDecimal
  derivedETH_lte: BigDecimal
  derivedETH_not: BigDecimal
  derivedETH_not_in: [BigDecimal!]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  name: String
  name_contains: String
  name_contains_nocase: String
  name_ends_with: String
  name_ends_with_nocase: String
  name_gt: String
  name_gte: String
  name_in: [String!]
  name_lt: String
  name_lte: String
  name_not: String
  name_not_contains: String
  name_not_contains_nocase: String
  name_not_ends_with: String
  name_not_ends_with_nocase: String
  name_not_in: [String!]
  name_not_starts_with: String
  name_not_starts_with_nocase: String
  name_starts_with: String
  name_starts_with_nocase: String
  or: [Token_filter]
  pairBase_: Pair_filter
  pairDayDataBase_: PairDayData_filter
  pairDayDataQuote_: PairDayData_filter
  pairQuote_: Pair_filter
  symbol: String
  symbol_contains: String
  symbol_contains_nocase: String
  symbol_ends_with: String
  symbol_ends_with_nocase: String
  symbol_gt: String
  symbol_gte: String
  symbol_in: [String!]
  symbol_lt: String
  symbol_lte: String
  symbol_not: String
  symbol_not_contains: String
  symbol_not_contains_nocase: String
  symbol_not_ends_with: String
  symbol_not_ends_with_nocase: String
  symbol_not_in: [String!]
  symbol_not_starts_with: String
  symbol_not_starts_with_nocase: String
  symbol_starts_with: String
  symbol_starts_with_nocase: String
  tokenDayData_: TokenDayData_filter
  totalLiquidity: BigDecimal
  totalLiquidity_gt: BigDecimal
  totalLiquidity_gte: BigDecimal
  totalLiquidity_in: [BigDecimal!]
  totalLiquidity_lt: BigDecimal
  totalLiquidity_lte: BigDecimal
  totalLiquidity_not: BigDecimal
  totalLiquidity_not_in: [BigDecimal!]
  totalSupply: BigInt
  totalSupply_gt: BigInt
  totalSupply_gte: BigInt
  totalSupply_in: [BigInt!]
  totalSupply_lt: BigInt
  totalSupply_lte: BigInt
  totalSupply_not: BigInt
  totalSupply_not_in: [BigInt!]
  tradeVolume: BigDecimal
  tradeVolumeUSD: BigDecimal
  tradeVolumeUSD_gt: BigDecimal
  tradeVolumeUSD_gte: BigDecimal
  tradeVolumeUSD_in: [BigDecimal!]
  tradeVolumeUSD_lt: BigDecimal
  tradeVolumeUSD_lte: BigDecimal
  tradeVolumeUSD_not: BigDecimal
  tradeVolumeUSD_not_in: [BigDecimal!]
  tradeVolume_gt: BigDecimal
  tradeVolume_gte: BigDecimal
  tradeVolume_in: [BigDecimal!]
  tradeVolume_lt: BigDecimal
  tradeVolume_lte: BigDecimal
  tradeVolume_not: BigDecimal
  tradeVolume_not_in: [BigDecimal!]
  txCount: BigInt
  txCount_gt: BigInt
  txCount_gte: BigInt
  txCount_in: [BigInt!]
  txCount_lt: BigInt
  txCount_lte: BigInt
  txCount_not: BigInt
  txCount_not_in: [BigInt!]
  untrackedVolumeUSD: BigDecimal
  untrackedVolumeUSD_gt: BigDecimal
  untrackedVolumeUSD_gte: BigDecimal
  untrackedVolumeUSD_in: [BigDecimal!]
  untrackedVolumeUSD_lt: BigDecimal
  untrackedVolumeUSD_lte: BigDecimal
  untrackedVolumeUSD_not: BigDecimal
  untrackedVolumeUSD_not_in: [BigDecimal!]
}

enum Token_orderBy {
  decimals
  derivedETH
  id
  name
  pairBase
  pairDayDataBase
  pairDayDataQuote
  pairQuote
  symbol
  tokenDayData
  totalLiquidity
  totalSupply
  tradeVolume
  tradeVolumeUSD
  txCount
  untrackedVolumeUSD
}

type Transaction {
  blockNumber: BigInt!
  burns(first: Int = 100, orderBy: Burn_orderBy, orderDirection: OrderDirection, skip: Int = 0, where: Burn_filter): [Burn!]!
  id: ID!
  mints(first: Int = 100, orderBy: Mint_orderBy, orderDirection: OrderDirection, skip: Int = 0, where: Mint_filter): [Mint!]!
  swaps(first: Int = 100, orderBy: Swap_orderBy, orderDirection: OrderDirection, skip: Int = 0, where: Swap_filter): [Swap!]!
  timestamp: BigInt!
}

input Transaction_filter {
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [Transaction_filter]
  blockNumber: BigInt
  blockNumber_gt: BigInt
  blockNumber_gte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_lt: BigInt
  blockNumber_lte: BigInt
  blockNumber_not: BigInt
  blockNumber_not_in: [BigInt!]
  burns: [String!]
  burns_: Burn_filter
  burns_contains: [String!]
  burns_contains_nocase: [String!]
  burns_not: [String!]
  burns_not_contains: [String!]
  burns_not_contains_nocase: [String!]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  mints: [String!]
  mints_: Mint_filter
  mints_contains: [String!]
  mints_contains_nocase: [String!]
  mints_not: [String!]
  mints_not_contains: [String!]
  mints_not_contains_nocase: [String!]
  or: [Transaction_filter]
  swaps: [String!]
  swaps_: Swap_filter
  swaps_contains: [String!]
  swaps_contains_nocase: [String!]
  swaps_not: [String!]
  swaps_not_contains: [String!]
  swaps_not_contains_nocase: [String!]
  timestamp: BigInt
  timestamp_gt: BigInt
  timestamp_gte: BigInt
  timestamp_in: [BigInt!]
  timestamp_lt: BigInt
  timestamp_lte: BigInt
  timestamp_not: BigInt
  timestamp_not_in: [BigInt!]
}

enum Transaction_orderBy {
  blockNumber
  burns
  id
  mints
  swaps
  timestamp
}

type UniswapDayData {
  dailyVolumeETH: BigDecimal!
  dailyVolumeUSD: BigDecimal!
  dailyVolumeUntracked: BigDecimal!
  date: Int!
  id: ID!
  totalLiquidityETH: BigDecimal!
  totalLiquidityUSD: BigDecimal!
  totalVolumeETH: BigDecimal!
  totalVolumeUSD: BigDecimal!
  txCount: BigInt!
}

input UniswapDayData_filter {
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [UniswapDayData_filter]
  dailyVolumeETH: BigDecimal
  dailyVolumeETH_gt: BigDecimal
  dailyVolumeETH_gte: BigDecimal
  dailyVolumeETH_in: [BigDecimal!]
  dailyVolumeETH_lt: BigDecimal
  dailyVolumeETH_lte: BigDecimal
  dailyVolumeETH_not: BigDecimal
  dailyVolumeETH_not_in: [BigDecimal!]
  dailyVolumeUSD: BigDecimal
  dailyVolumeUSD_gt: BigDecimal
  dailyVolumeUSD_gte: BigDecimal
  dailyVolumeUSD_in: [BigDecimal!]
  dailyVolumeUSD_lt: BigDecimal
  dailyVolumeUSD_lte: BigDecimal
  dailyVolumeUSD_not: BigDecimal
  dailyVolumeUSD_not_in: [BigDecimal!]
  dailyVolumeUntracked: BigDecimal
  dailyVolumeUntracked_gt: BigDecimal
  dailyVolumeUntracked_gte: BigDecimal
  dailyVolumeUntracked_in: [BigDecimal!]
  dailyVolumeUntracked_lt: BigDecimal
  dailyVolumeUntracked_lte: BigDecimal
  dailyVolumeUntracked_not: BigDecimal
  dailyVolumeUntracked_not_in: [BigDecimal!]
  date: Int
  date_gt: Int
  date_gte: Int
  date_in: [Int!]
  date_lt: Int
  date_lte: Int
  date_not: Int
  date_not_in: [Int!]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  or: [UniswapDayData_filter]
  totalLiquidityETH: BigDecimal
  totalLiquidityETH_gt: BigDecimal
  totalLiquidityETH_gte: BigDecimal
  totalLiquidityETH_in: [BigDecimal!]
  totalLiquidityETH_lt: BigDecimal
  totalLiquidityETH_lte: BigDecimal
  totalLiquidityETH_not: BigDecimal
  totalLiquidityETH_not_in: [BigDecimal!]
  totalLiquidityUSD: BigDecimal
  totalLiquidityUSD_gt: BigDecimal
  totalLiquidityUSD_gte: BigDecimal
  totalLiquidityUSD_in: [BigDecimal!]
  totalLiquidityUSD_lt: BigDecimal
  totalLiquidityUSD_lte: BigDecimal
  totalLiquidityUSD_not: BigDecimal
  totalLiquidityUSD_not_in: [BigDecimal!]
  totalVolumeETH: BigDecimal
  totalVolumeETH_gt: BigDecimal
  totalVolumeETH_gte: BigDecimal
  totalVolumeETH_in: [BigDecimal!]
  totalVolumeETH_lt: BigDecimal
  totalVolumeETH_lte: BigDecimal
  totalVolumeETH_not: BigDecimal
  totalVolumeETH_not_in: [BigDecimal!]
  totalVolumeUSD: BigDecimal
  totalVolumeUSD_gt: BigDecimal
  totalVolumeUSD_gte: BigDecimal
  totalVolumeUSD_in: [BigDecimal!]
  totalVolumeUSD_lt: BigDecimal
  totalVolumeUSD_lte: BigDecimal
  totalVolumeUSD_not: BigDecimal
  totalVolumeUSD_not_in: [BigDecimal!]
  txCount: BigInt
  txCount_gt: BigInt
  txCount_gte: BigInt
  txCount_in: [BigInt!]
  txCount_lt: BigInt
  txCount_lte: BigInt
  txCount_not: BigInt
  txCount_not_in: [BigInt!]
}

enum UniswapDayData_orderBy {
  dailyVolumeETH
  dailyVolumeUSD
  dailyVolumeUntracked
  date
  id
  totalLiquidityETH
  totalLiquidityUSD
  totalVolumeETH
  totalVolumeUSD
  txCount
}

type UniswapFactory {
  id: ID!
  pairCount: Int!
  totalLiquidityETH: BigDecimal!
  totalLiquidityUSD: BigDecimal!
  totalVolumeETH: BigDecimal!
  totalVolumeUSD: BigDecimal!
  txCount: BigInt!
  untrackedVolumeUSD: BigDecimal!
}

input UniswapFactory_filter {
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [UniswapFactory_filter]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  or: [UniswapFactory_filter]
  pairCount: Int
  pairCount_gt: Int
  pairCount_gte: Int
  pairCount_in: [Int!]
  pairCount_lt: Int
  pairCount_lte: Int
  pairCount_not: Int
  pairCount_not_in: [Int!]
  totalLiquidityETH: BigDecimal
  totalLiquidityETH_gt: BigDecimal
  totalLiquidityETH_gte: BigDecimal
  totalLiquidityETH_in: [BigDecimal!]
  totalLiquidityETH_lt: BigDecimal
  totalLiquidityETH_lte: BigDecimal
  totalLiquidityETH_not: BigDecimal
  totalLiquidityETH_not_in: [BigDecimal!]
  totalLiquidityUSD: BigDecimal
  totalLiquidityUSD_gt: BigDecimal
  totalLiquidityUSD_gte: BigDecimal
  totalLiquidityUSD_in: [BigDecimal!]
  totalLiquidityUSD_lt: BigDecimal
  totalLiquidityUSD_lte: BigDecimal
  totalLiquidityUSD_not: BigDecimal
  totalLiquidityUSD_not_in: [BigDecimal!]
  totalVolumeETH: BigDecimal
  totalVolumeETH_gt: BigDecimal
  totalVolumeETH_gte: BigDecimal
  totalVolumeETH_in: [BigDecimal!]
  totalVolumeETH_lt: BigDecimal
  totalVolumeETH_lte: BigDecimal
  totalVolumeETH_not: BigDecimal
  totalVolumeETH_not_in: [BigDecimal!]
  totalVolumeUSD: BigDecimal
  totalVolumeUSD_gt: BigDecimal
  totalVolumeUSD_gte: BigDecimal
  totalVolumeUSD_in: [BigDecimal!]
  totalVolumeUSD_lt: BigDecimal
  totalVolumeUSD_lte: BigDecimal
  totalVolumeUSD_not: BigDecimal
  totalVolumeUSD_not_in: [BigDecimal!]
  txCount: BigInt
  txCount_gt: BigInt
  txCount_gte: BigInt
  txCount_in: [BigInt!]
  txCount_lt: BigInt
  txCount_lte: BigInt
  txCount_not: BigInt
  txCount_not_in: [BigInt!]
  untrackedVolumeUSD: BigDecimal
  untrackedVolumeUSD_gt: BigDecimal
  untrackedVolumeUSD_gte: BigDecimal
  untrackedVolumeUSD_in: [BigDecimal!]
  untrackedVolumeUSD_lt: BigDecimal
  untrackedVolumeUSD_lte: BigDecimal
  untrackedVolumeUSD_not: BigDecimal
  untrackedVolumeUSD_not_in: [BigDecimal!]
}

enum UniswapFactory_orderBy {
  id
  pairCount
  totalLiquidityETH
  totalLiquidityUSD
  totalVolumeETH
  totalVolumeUSD
  txCount
  untrackedVolumeUSD
}

type User {
  id: ID!
  liquidityPositions(first: Int = 100, orderBy: LiquidityPosition_orderBy, orderDirection: OrderDirection, skip: Int = 0, where: LiquidityPosition_filter): [LiquidityPosition!]
  usdSwapped: BigDecimal!
}

input User_filter {
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [User_filter]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  liquidityPositions_: LiquidityPosition_filter
  or: [User_filter]
  usdSwapped: BigDecimal
  usdSwapped_gt: BigDecimal
  usdSwapped_gte: BigDecimal
  usdSwapped_in: [BigDecimal!]
  usdSwapped_lt: BigDecimal
  usdSwapped_lte: BigDecimal
  usdSwapped_not: BigDecimal
  usdSwapped_not_in: [BigDecimal!]
}

enum User_orderBy {
  id
  liquidityPositions
  usdSwapped
}

type _Block_ {
  """The hash of the block"""
  hash: Bytes

  """The block number"""
  number: Int!

  """Integer representation of the timestamp stored in blocks for the chain"""
  timestamp: Int
}

"""The type for the top-level _meta field"""
type _Meta_ {
  "Information about a specific subgraph block. The hash of the block\nwill be null if the _meta field has a block constraint that asks for\na block number. It will be filled if the _meta field has no block constraint\nand therefore asks for the latest  block\n"
  block: _Block_!

  """The deployment ID"""
  deployment: String!

  """If `true`, the subgraph encountered indexing errors at some past block"""
  hasIndexingErrors: Boolean!
}

enum _SubgraphErrorPolicy_ {
  """Data will be returned even if the subgraph has indexing errors"""
  allow

  """
  If the subgraph has indexing errors, data will be omitted. The default.
  """
  deny
}